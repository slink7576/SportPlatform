/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.0.0.0 (NJsonSchema v9.12.2.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IClient {
    /**
     * @return Success
     */
    getAllUsers(): Observable<UsersListViewModel>;
    /**
     * @return Success
     */
    get(id: number): Observable<void>;
    /**
     * @param command (optional) 
     * @return Success
     */
    registerUser(command: CreateUserCommand | null | undefined): Observable<UserViewModel>;
    /**
     * @param command (optional) 
     * @return Success
     */
    login(command: LoginUserQuery | null | undefined): Observable<boolean>;
    /**
     * @param command (optional) 
     * @return Success
     */
    putUser(id: number, command: UpdateUserCommand | null | undefined): Observable<UserDTO>;
    /**
     * @return Success
     */
    deleteUser(id: number): Observable<void>;
}

@Injectable()
export class Client implements IClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllUsers(): Observable<UsersListViewModel> {
        let url_ = this.baseUrl + "/api/Users/GetAllUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUsers(<any>response_);
                } catch (e) {
                    return <Observable<UsersListViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<UsersListViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUsers(response: HttpResponseBase): Observable<UsersListViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UsersListViewModel.fromJS(resultData200) : new UsersListViewModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UsersListViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    get(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Users/GetUser/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param command (optional) 
     * @return Success
     */
    registerUser(command: CreateUserCommand | null | undefined): Observable<UserViewModel> {
        let url_ = this.baseUrl + "/api/Users/RegisterUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterUser(<any>response_);
                } catch (e) {
                    return <Observable<UserViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterUser(response: HttpResponseBase): Observable<UserViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserViewModel.fromJS(resultData200) : new UserViewModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserViewModel>(<any>null);
    }

    /**
     * @param command (optional) 
     * @return Success
     */
    login(command: LoginUserQuery | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Users/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param command (optional) 
     * @return Success
     */
    putUser(id: number, command: UpdateUserCommand | null | undefined): Observable<UserDTO> {
        let url_ = this.baseUrl + "/api/Users/PutUser/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPutUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutUser(<any>response_);
                } catch (e) {
                    return <Observable<UserDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDTO>><any>_observableThrow(response_);
        }));
    }

    protected processPutUser(response: HttpResponseBase): Observable<UserDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDTO.fromJS(resultData200) : new UserDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDTO>(<any>null);
    }

    /**
     * @return Success
     */
    deleteUser(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Users/DeleteUser/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export class UsersListViewModel implements IUsersListViewModel {
    users?: UserDTO[] | undefined;

    constructor(data?: IUsersListViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["users"] && data["users"].constructor === Array) {
                this.users = [];
                for (let item of data["users"])
                    this.users.push(UserDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UsersListViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UsersListViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.users && this.users.constructor === Array) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUsersListViewModel {
    users?: UserDTO[] | undefined;
}

export class UserDTO implements IUserDTO {
    userId?: number | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    age?: number | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    submittedEmail?: boolean | undefined;
    photoUrl?: string | undefined;
    workerId?: number | undefined;
    worker?: Worker | undefined;
    userType?: UserDTOUserType | undefined;
    photos?: Photo[] | undefined;
    isWorker?: boolean | undefined;

    constructor(data?: IUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.age = data["age"];
            this.phone = data["phone"];
            this.email = data["email"];
            this.submittedEmail = data["submittedEmail"];
            this.photoUrl = data["photoUrl"];
            this.workerId = data["workerId"];
            this.worker = data["worker"] ? Worker.fromJS(data["worker"]) : <any>undefined;
            this.userType = data["userType"];
            if (data["photos"] && data["photos"].constructor === Array) {
                this.photos = [];
                for (let item of data["photos"])
                    this.photos.push(Photo.fromJS(item));
            }
            this.isWorker = data["isWorker"];
        }
    }

    static fromJS(data: any): UserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["age"] = this.age;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["submittedEmail"] = this.submittedEmail;
        data["photoUrl"] = this.photoUrl;
        data["workerId"] = this.workerId;
        data["worker"] = this.worker ? this.worker.toJSON() : <any>undefined;
        data["userType"] = this.userType;
        if (this.photos && this.photos.constructor === Array) {
            data["photos"] = [];
            for (let item of this.photos)
                data["photos"].push(item.toJSON());
        }
        data["isWorker"] = this.isWorker;
        return data; 
    }
}

export interface IUserDTO {
    userId?: number | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    age?: number | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    submittedEmail?: boolean | undefined;
    photoUrl?: string | undefined;
    workerId?: number | undefined;
    worker?: Worker | undefined;
    userType?: UserDTOUserType | undefined;
    photos?: Photo[] | undefined;
    isWorker?: boolean | undefined;
}

export class Worker implements IWorker {
    workerId?: number | undefined;
    about?: string | undefined;
    workPlace?: string | undefined;
    workTitle?: string | undefined;
    workDescription?: string | undefined;
    userId?: number | undefined;
    user?: User | undefined;
    workHistories?: WorkHistory[] | undefined;
    courses?: Course[] | undefined;
    foodPrograms?: FoodProgram[] | undefined;
    certificates?: Certificate[] | undefined;
    trainingPrograms?: TrainingProgram[] | undefined;

    constructor(data?: IWorker) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.workerId = data["workerId"];
            this.about = data["about"];
            this.workPlace = data["workPlace"];
            this.workTitle = data["workTitle"];
            this.workDescription = data["workDescription"];
            this.userId = data["userId"];
            this.user = data["user"] ? User.fromJS(data["user"]) : <any>undefined;
            if (data["workHistories"] && data["workHistories"].constructor === Array) {
                this.workHistories = [];
                for (let item of data["workHistories"])
                    this.workHistories.push(WorkHistory.fromJS(item));
            }
            if (data["courses"] && data["courses"].constructor === Array) {
                this.courses = [];
                for (let item of data["courses"])
                    this.courses.push(Course.fromJS(item));
            }
            if (data["foodPrograms"] && data["foodPrograms"].constructor === Array) {
                this.foodPrograms = [];
                for (let item of data["foodPrograms"])
                    this.foodPrograms.push(FoodProgram.fromJS(item));
            }
            if (data["certificates"] && data["certificates"].constructor === Array) {
                this.certificates = [];
                for (let item of data["certificates"])
                    this.certificates.push(Certificate.fromJS(item));
            }
            if (data["trainingPrograms"] && data["trainingPrograms"].constructor === Array) {
                this.trainingPrograms = [];
                for (let item of data["trainingPrograms"])
                    this.trainingPrograms.push(TrainingProgram.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Worker {
        data = typeof data === 'object' ? data : {};
        let result = new Worker();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workerId"] = this.workerId;
        data["about"] = this.about;
        data["workPlace"] = this.workPlace;
        data["workTitle"] = this.workTitle;
        data["workDescription"] = this.workDescription;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (this.workHistories && this.workHistories.constructor === Array) {
            data["workHistories"] = [];
            for (let item of this.workHistories)
                data["workHistories"].push(item.toJSON());
        }
        if (this.courses && this.courses.constructor === Array) {
            data["courses"] = [];
            for (let item of this.courses)
                data["courses"].push(item.toJSON());
        }
        if (this.foodPrograms && this.foodPrograms.constructor === Array) {
            data["foodPrograms"] = [];
            for (let item of this.foodPrograms)
                data["foodPrograms"].push(item.toJSON());
        }
        if (this.certificates && this.certificates.constructor === Array) {
            data["certificates"] = [];
            for (let item of this.certificates)
                data["certificates"].push(item.toJSON());
        }
        if (this.trainingPrograms && this.trainingPrograms.constructor === Array) {
            data["trainingPrograms"] = [];
            for (let item of this.trainingPrograms)
                data["trainingPrograms"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IWorker {
    workerId?: number | undefined;
    about?: string | undefined;
    workPlace?: string | undefined;
    workTitle?: string | undefined;
    workDescription?: string | undefined;
    userId?: number | undefined;
    user?: User | undefined;
    workHistories?: WorkHistory[] | undefined;
    courses?: Course[] | undefined;
    foodPrograms?: FoodProgram[] | undefined;
    certificates?: Certificate[] | undefined;
    trainingPrograms?: TrainingProgram[] | undefined;
}

export class Photo implements IPhoto {
    photoId?: number | undefined;
    postDate?: Date | undefined;
    description?: string | undefined;
    photoUrl?: string | undefined;
    userId?: number | undefined;
    user?: User | undefined;

    constructor(data?: IPhoto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.photoId = data["photoId"];
            this.postDate = data["postDate"] ? new Date(data["postDate"].toString()) : <any>undefined;
            this.description = data["description"];
            this.photoUrl = data["photoUrl"];
            this.userId = data["userId"];
            this.user = data["user"] ? User.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Photo {
        data = typeof data === 'object' ? data : {};
        let result = new Photo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["photoId"] = this.photoId;
        data["postDate"] = this.postDate ? this.postDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["photoUrl"] = this.photoUrl;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPhoto {
    photoId?: number | undefined;
    postDate?: Date | undefined;
    description?: string | undefined;
    photoUrl?: string | undefined;
    userId?: number | undefined;
    user?: User | undefined;
}

export class User implements IUser {
    userId?: number | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    age?: number | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    submittedEmail?: boolean | undefined;
    password?: string | undefined;
    photoUrl?: string | undefined;
    worker?: Worker | undefined;
    userType?: UserType | undefined;
    photos?: Photo[] | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.age = data["age"];
            this.phone = data["phone"];
            this.email = data["email"];
            this.submittedEmail = data["submittedEmail"];
            this.password = data["password"];
            this.photoUrl = data["photoUrl"];
            this.worker = data["worker"] ? Worker.fromJS(data["worker"]) : <any>undefined;
            this.userType = data["userType"];
            if (data["photos"] && data["photos"].constructor === Array) {
                this.photos = [];
                for (let item of data["photos"])
                    this.photos.push(Photo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["age"] = this.age;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["submittedEmail"] = this.submittedEmail;
        data["password"] = this.password;
        data["photoUrl"] = this.photoUrl;
        data["worker"] = this.worker ? this.worker.toJSON() : <any>undefined;
        data["userType"] = this.userType;
        if (this.photos && this.photos.constructor === Array) {
            data["photos"] = [];
            for (let item of this.photos)
                data["photos"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUser {
    userId?: number | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    age?: number | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    submittedEmail?: boolean | undefined;
    password?: string | undefined;
    photoUrl?: string | undefined;
    worker?: Worker | undefined;
    userType?: UserType | undefined;
    photos?: Photo[] | undefined;
}

export class WorkHistory implements IWorkHistory {
    workHistoryId?: number | undefined;
    startWork?: Date | undefined;
    endWork?: Date | undefined;
    title?: string | undefined;
    description?: string | undefined;
    workerId?: number | undefined;
    worker?: Worker | undefined;

    constructor(data?: IWorkHistory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.workHistoryId = data["workHistoryId"];
            this.startWork = data["startWork"] ? new Date(data["startWork"].toString()) : <any>undefined;
            this.endWork = data["endWork"] ? new Date(data["endWork"].toString()) : <any>undefined;
            this.title = data["title"];
            this.description = data["description"];
            this.workerId = data["workerId"];
            this.worker = data["worker"] ? Worker.fromJS(data["worker"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WorkHistory {
        data = typeof data === 'object' ? data : {};
        let result = new WorkHistory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workHistoryId"] = this.workHistoryId;
        data["startWork"] = this.startWork ? this.startWork.toISOString() : <any>undefined;
        data["endWork"] = this.endWork ? this.endWork.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["description"] = this.description;
        data["workerId"] = this.workerId;
        data["worker"] = this.worker ? this.worker.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IWorkHistory {
    workHistoryId?: number | undefined;
    startWork?: Date | undefined;
    endWork?: Date | undefined;
    title?: string | undefined;
    description?: string | undefined;
    workerId?: number | undefined;
    worker?: Worker | undefined;
}

export class Course implements ICourse {
    courseId?: number | undefined;
    name?: string | undefined;
    startLearning?: Date | undefined;
    endLearning?: Date | undefined;
    place?: string | undefined;
    documentUrl?: string | undefined;
    workerId?: number | undefined;
    worker?: Worker | undefined;

    constructor(data?: ICourse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.courseId = data["courseId"];
            this.name = data["name"];
            this.startLearning = data["startLearning"] ? new Date(data["startLearning"].toString()) : <any>undefined;
            this.endLearning = data["endLearning"] ? new Date(data["endLearning"].toString()) : <any>undefined;
            this.place = data["place"];
            this.documentUrl = data["documentUrl"];
            this.workerId = data["workerId"];
            this.worker = data["worker"] ? Worker.fromJS(data["worker"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Course {
        data = typeof data === 'object' ? data : {};
        let result = new Course();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["courseId"] = this.courseId;
        data["name"] = this.name;
        data["startLearning"] = this.startLearning ? this.startLearning.toISOString() : <any>undefined;
        data["endLearning"] = this.endLearning ? this.endLearning.toISOString() : <any>undefined;
        data["place"] = this.place;
        data["documentUrl"] = this.documentUrl;
        data["workerId"] = this.workerId;
        data["worker"] = this.worker ? this.worker.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICourse {
    courseId?: number | undefined;
    name?: string | undefined;
    startLearning?: Date | undefined;
    endLearning?: Date | undefined;
    place?: string | undefined;
    documentUrl?: string | undefined;
    workerId?: number | undefined;
    worker?: Worker | undefined;
}

export class FoodProgram implements IFoodProgram {
    foodProgramId?: number | undefined;
    name?: string | undefined;
    workerId?: number | undefined;
    worker?: Worker | undefined;
    menus?: Menu[] | undefined;

    constructor(data?: IFoodProgram) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.foodProgramId = data["foodProgramId"];
            this.name = data["name"];
            this.workerId = data["workerId"];
            this.worker = data["worker"] ? Worker.fromJS(data["worker"]) : <any>undefined;
            if (data["menus"] && data["menus"].constructor === Array) {
                this.menus = [];
                for (let item of data["menus"])
                    this.menus.push(Menu.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FoodProgram {
        data = typeof data === 'object' ? data : {};
        let result = new FoodProgram();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foodProgramId"] = this.foodProgramId;
        data["name"] = this.name;
        data["workerId"] = this.workerId;
        data["worker"] = this.worker ? this.worker.toJSON() : <any>undefined;
        if (this.menus && this.menus.constructor === Array) {
            data["menus"] = [];
            for (let item of this.menus)
                data["menus"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFoodProgram {
    foodProgramId?: number | undefined;
    name?: string | undefined;
    workerId?: number | undefined;
    worker?: Worker | undefined;
    menus?: Menu[] | undefined;
}

export class Certificate implements ICertificate {
    certificateId?: number | undefined;
    name?: string | undefined;
    achieveDate?: Date | undefined;
    certificateUrl?: string | undefined;
    workerId?: number | undefined;
    worker?: Worker | undefined;

    constructor(data?: ICertificate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.certificateId = data["certificateId"];
            this.name = data["name"];
            this.achieveDate = data["achieveDate"] ? new Date(data["achieveDate"].toString()) : <any>undefined;
            this.certificateUrl = data["certificateUrl"];
            this.workerId = data["workerId"];
            this.worker = data["worker"] ? Worker.fromJS(data["worker"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Certificate {
        data = typeof data === 'object' ? data : {};
        let result = new Certificate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["certificateId"] = this.certificateId;
        data["name"] = this.name;
        data["achieveDate"] = this.achieveDate ? this.achieveDate.toISOString() : <any>undefined;
        data["certificateUrl"] = this.certificateUrl;
        data["workerId"] = this.workerId;
        data["worker"] = this.worker ? this.worker.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICertificate {
    certificateId?: number | undefined;
    name?: string | undefined;
    achieveDate?: Date | undefined;
    certificateUrl?: string | undefined;
    workerId?: number | undefined;
    worker?: Worker | undefined;
}

export class TrainingProgram implements ITrainingProgram {
    trainingProgramId?: number | undefined;
    name?: string | undefined;
    description?: string | undefined;
    workerId?: number | undefined;
    worker?: Worker | undefined;
    trainings?: Training[] | undefined;

    constructor(data?: ITrainingProgram) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.trainingProgramId = data["trainingProgramId"];
            this.name = data["name"];
            this.description = data["description"];
            this.workerId = data["workerId"];
            this.worker = data["worker"] ? Worker.fromJS(data["worker"]) : <any>undefined;
            if (data["trainings"] && data["trainings"].constructor === Array) {
                this.trainings = [];
                for (let item of data["trainings"])
                    this.trainings.push(Training.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TrainingProgram {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingProgram();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingProgramId"] = this.trainingProgramId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["workerId"] = this.workerId;
        data["worker"] = this.worker ? this.worker.toJSON() : <any>undefined;
        if (this.trainings && this.trainings.constructor === Array) {
            data["trainings"] = [];
            for (let item of this.trainings)
                data["trainings"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITrainingProgram {
    trainingProgramId?: number | undefined;
    name?: string | undefined;
    description?: string | undefined;
    workerId?: number | undefined;
    worker?: Worker | undefined;
    trainings?: Training[] | undefined;
}

export class Menu implements IMenu {
    menuId?: number | undefined;
    time?: Date | undefined;
    description?: string | undefined;
    foodProgramId?: number | undefined;
    foodProgram?: FoodProgram | undefined;
    dishMenus?: DishMenu[] | undefined;

    constructor(data?: IMenu) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.menuId = data["menuId"];
            this.time = data["time"] ? new Date(data["time"].toString()) : <any>undefined;
            this.description = data["description"];
            this.foodProgramId = data["foodProgramId"];
            this.foodProgram = data["foodProgram"] ? FoodProgram.fromJS(data["foodProgram"]) : <any>undefined;
            if (data["dishMenus"] && data["dishMenus"].constructor === Array) {
                this.dishMenus = [];
                for (let item of data["dishMenus"])
                    this.dishMenus.push(DishMenu.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Menu {
        data = typeof data === 'object' ? data : {};
        let result = new Menu();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["menuId"] = this.menuId;
        data["time"] = this.time ? this.time.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["foodProgramId"] = this.foodProgramId;
        data["foodProgram"] = this.foodProgram ? this.foodProgram.toJSON() : <any>undefined;
        if (this.dishMenus && this.dishMenus.constructor === Array) {
            data["dishMenus"] = [];
            for (let item of this.dishMenus)
                data["dishMenus"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IMenu {
    menuId?: number | undefined;
    time?: Date | undefined;
    description?: string | undefined;
    foodProgramId?: number | undefined;
    foodProgram?: FoodProgram | undefined;
    dishMenus?: DishMenu[] | undefined;
}

export class Training implements ITraining {
    trainingId?: number | undefined;
    dayOfWeek?: Date | undefined;
    description?: string | undefined;
    trainingProgramId?: number | undefined;
    trainingProgram?: TrainingProgram | undefined;
    trainingActions?: TrainingAction[] | undefined;

    constructor(data?: ITraining) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.trainingId = data["trainingId"];
            this.dayOfWeek = data["dayOfWeek"] ? new Date(data["dayOfWeek"].toString()) : <any>undefined;
            this.description = data["description"];
            this.trainingProgramId = data["trainingProgramId"];
            this.trainingProgram = data["trainingProgram"] ? TrainingProgram.fromJS(data["trainingProgram"]) : <any>undefined;
            if (data["trainingActions"] && data["trainingActions"].constructor === Array) {
                this.trainingActions = [];
                for (let item of data["trainingActions"])
                    this.trainingActions.push(TrainingAction.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Training {
        data = typeof data === 'object' ? data : {};
        let result = new Training();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingId"] = this.trainingId;
        data["dayOfWeek"] = this.dayOfWeek ? this.dayOfWeek.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["trainingProgramId"] = this.trainingProgramId;
        data["trainingProgram"] = this.trainingProgram ? this.trainingProgram.toJSON() : <any>undefined;
        if (this.trainingActions && this.trainingActions.constructor === Array) {
            data["trainingActions"] = [];
            for (let item of this.trainingActions)
                data["trainingActions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITraining {
    trainingId?: number | undefined;
    dayOfWeek?: Date | undefined;
    description?: string | undefined;
    trainingProgramId?: number | undefined;
    trainingProgram?: TrainingProgram | undefined;
    trainingActions?: TrainingAction[] | undefined;
}

export class DishMenu implements IDishMenu {
    dishMenuId?: number | undefined;
    dishId?: number | undefined;
    dish?: Dish | undefined;
    menuId?: number | undefined;
    menu?: Menu | undefined;

    constructor(data?: IDishMenu) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dishMenuId = data["dishMenuId"];
            this.dishId = data["dishId"];
            this.dish = data["dish"] ? Dish.fromJS(data["dish"]) : <any>undefined;
            this.menuId = data["menuId"];
            this.menu = data["menu"] ? Menu.fromJS(data["menu"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DishMenu {
        data = typeof data === 'object' ? data : {};
        let result = new DishMenu();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dishMenuId"] = this.dishMenuId;
        data["dishId"] = this.dishId;
        data["dish"] = this.dish ? this.dish.toJSON() : <any>undefined;
        data["menuId"] = this.menuId;
        data["menu"] = this.menu ? this.menu.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IDishMenu {
    dishMenuId?: number | undefined;
    dishId?: number | undefined;
    dish?: Dish | undefined;
    menuId?: number | undefined;
    menu?: Menu | undefined;
}

export class TrainingAction implements ITrainingAction {
    trainingActionId?: number | undefined;
    name?: string | undefined;
    amount?: number | undefined;
    repeats?: number | undefined;
    description?: string | undefined;
    trainingId?: number | undefined;
    training?: Training | undefined;

    constructor(data?: ITrainingAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.trainingActionId = data["trainingActionId"];
            this.name = data["name"];
            this.amount = data["amount"];
            this.repeats = data["repeats"];
            this.description = data["description"];
            this.trainingId = data["trainingId"];
            this.training = data["training"] ? Training.fromJS(data["training"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingAction {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingActionId"] = this.trainingActionId;
        data["name"] = this.name;
        data["amount"] = this.amount;
        data["repeats"] = this.repeats;
        data["description"] = this.description;
        data["trainingId"] = this.trainingId;
        data["training"] = this.training ? this.training.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ITrainingAction {
    trainingActionId?: number | undefined;
    name?: string | undefined;
    amount?: number | undefined;
    repeats?: number | undefined;
    description?: string | undefined;
    trainingId?: number | undefined;
    training?: Training | undefined;
}

export class Dish implements IDish {
    dishId?: number | undefined;
    name?: string | undefined;
    weight?: number | undefined;
    calories?: number | undefined;
    dishMenus?: DishMenu[] | undefined;
    dishIngridients?: DishIngridient[] | undefined;

    constructor(data?: IDish) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dishId = data["dishId"];
            this.name = data["name"];
            this.weight = data["weight"];
            this.calories = data["calories"];
            if (data["dishMenus"] && data["dishMenus"].constructor === Array) {
                this.dishMenus = [];
                for (let item of data["dishMenus"])
                    this.dishMenus.push(DishMenu.fromJS(item));
            }
            if (data["dishIngridients"] && data["dishIngridients"].constructor === Array) {
                this.dishIngridients = [];
                for (let item of data["dishIngridients"])
                    this.dishIngridients.push(DishIngridient.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Dish {
        data = typeof data === 'object' ? data : {};
        let result = new Dish();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dishId"] = this.dishId;
        data["name"] = this.name;
        data["weight"] = this.weight;
        data["calories"] = this.calories;
        if (this.dishMenus && this.dishMenus.constructor === Array) {
            data["dishMenus"] = [];
            for (let item of this.dishMenus)
                data["dishMenus"].push(item.toJSON());
        }
        if (this.dishIngridients && this.dishIngridients.constructor === Array) {
            data["dishIngridients"] = [];
            for (let item of this.dishIngridients)
                data["dishIngridients"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDish {
    dishId?: number | undefined;
    name?: string | undefined;
    weight?: number | undefined;
    calories?: number | undefined;
    dishMenus?: DishMenu[] | undefined;
    dishIngridients?: DishIngridient[] | undefined;
}

export class DishIngridient implements IDishIngridient {
    dishIngridientId?: number | undefined;
    dishId?: number | undefined;
    dish?: Dish | undefined;
    ingridientId?: number | undefined;
    ingridient?: Ingridient | undefined;

    constructor(data?: IDishIngridient) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dishIngridientId = data["dishIngridientId"];
            this.dishId = data["dishId"];
            this.dish = data["dish"] ? Dish.fromJS(data["dish"]) : <any>undefined;
            this.ingridientId = data["ingridientId"];
            this.ingridient = data["ingridient"] ? Ingridient.fromJS(data["ingridient"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DishIngridient {
        data = typeof data === 'object' ? data : {};
        let result = new DishIngridient();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dishIngridientId"] = this.dishIngridientId;
        data["dishId"] = this.dishId;
        data["dish"] = this.dish ? this.dish.toJSON() : <any>undefined;
        data["ingridientId"] = this.ingridientId;
        data["ingridient"] = this.ingridient ? this.ingridient.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IDishIngridient {
    dishIngridientId?: number | undefined;
    dishId?: number | undefined;
    dish?: Dish | undefined;
    ingridientId?: number | undefined;
    ingridient?: Ingridient | undefined;
}

export class Ingridient implements IIngridient {
    ingridientId?: number | undefined;
    name?: string | undefined;
    dishIngridients?: DishIngridient[] | undefined;

    constructor(data?: IIngridient) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ingridientId = data["ingridientId"];
            this.name = data["name"];
            if (data["dishIngridients"] && data["dishIngridients"].constructor === Array) {
                this.dishIngridients = [];
                for (let item of data["dishIngridients"])
                    this.dishIngridients.push(DishIngridient.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Ingridient {
        data = typeof data === 'object' ? data : {};
        let result = new Ingridient();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ingridientId"] = this.ingridientId;
        data["name"] = this.name;
        if (this.dishIngridients && this.dishIngridients.constructor === Array) {
            data["dishIngridients"] = [];
            for (let item of this.dishIngridients)
                data["dishIngridients"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IIngridient {
    ingridientId?: number | undefined;
    name?: string | undefined;
    dishIngridients?: DishIngridient[] | undefined;
}

export class CreateUserCommand implements ICreateUserCommand {
    name?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;

    constructor(data?: ICreateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.email = data["email"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): CreateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["email"] = this.email;
        data["password"] = this.password;
        return data; 
    }
}

export interface ICreateUserCommand {
    name?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
}

export class UserViewModel implements IUserViewModel {
    userId?: number | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    age?: number | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    submittedEmail?: boolean | undefined;
    photoUrl?: string | undefined;
    workerId?: number | undefined;
    worker?: Worker | undefined;
    userType?: UserViewModelUserType | undefined;
    photos?: Photo[] | undefined;
    isWorker?: boolean | undefined;

    constructor(data?: IUserViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.age = data["age"];
            this.phone = data["phone"];
            this.email = data["email"];
            this.submittedEmail = data["submittedEmail"];
            this.photoUrl = data["photoUrl"];
            this.workerId = data["workerId"];
            this.worker = data["worker"] ? Worker.fromJS(data["worker"]) : <any>undefined;
            this.userType = data["userType"];
            if (data["photos"] && data["photos"].constructor === Array) {
                this.photos = [];
                for (let item of data["photos"])
                    this.photos.push(Photo.fromJS(item));
            }
            this.isWorker = data["isWorker"];
        }
    }

    static fromJS(data: any): UserViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["age"] = this.age;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["submittedEmail"] = this.submittedEmail;
        data["photoUrl"] = this.photoUrl;
        data["workerId"] = this.workerId;
        data["worker"] = this.worker ? this.worker.toJSON() : <any>undefined;
        data["userType"] = this.userType;
        if (this.photos && this.photos.constructor === Array) {
            data["photos"] = [];
            for (let item of this.photos)
                data["photos"].push(item.toJSON());
        }
        data["isWorker"] = this.isWorker;
        return data; 
    }
}

export interface IUserViewModel {
    userId?: number | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    age?: number | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    submittedEmail?: boolean | undefined;
    photoUrl?: string | undefined;
    workerId?: number | undefined;
    worker?: Worker | undefined;
    userType?: UserViewModelUserType | undefined;
    photos?: Photo[] | undefined;
    isWorker?: boolean | undefined;
}

export class LoginUserQuery implements ILoginUserQuery {
    email?: string | undefined;
    password?: string | undefined;

    constructor(data?: ILoginUserQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.email = data["email"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): LoginUserQuery {
        data = typeof data === 'object' ? data : {};
        let result = new LoginUserQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data; 
    }
}

export interface ILoginUserQuery {
    email?: string | undefined;
    password?: string | undefined;
}

export class UpdateUserCommand implements IUpdateUserCommand {
    userId?: number | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    age?: number | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    submittedEmail?: boolean | undefined;
    password?: string | undefined;
    photoUrl?: string | undefined;
    userType?: UpdateUserCommandUserType | undefined;
    workerId?: number | undefined;
    worker?: Worker | undefined;

    constructor(data?: IUpdateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.age = data["age"];
            this.phone = data["phone"];
            this.email = data["email"];
            this.submittedEmail = data["submittedEmail"];
            this.password = data["password"];
            this.photoUrl = data["photoUrl"];
            this.userType = data["userType"];
            this.workerId = data["workerId"];
            this.worker = data["worker"] ? Worker.fromJS(data["worker"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["age"] = this.age;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["submittedEmail"] = this.submittedEmail;
        data["password"] = this.password;
        data["photoUrl"] = this.photoUrl;
        data["userType"] = this.userType;
        data["workerId"] = this.workerId;
        data["worker"] = this.worker ? this.worker.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUpdateUserCommand {
    userId?: number | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    age?: number | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    submittedEmail?: boolean | undefined;
    password?: string | undefined;
    photoUrl?: string | undefined;
    userType?: UpdateUserCommandUserType | undefined;
    workerId?: number | undefined;
    worker?: Worker | undefined;
}

export enum UserDTOUserType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum UserType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum UserViewModelUserType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum UpdateUserCommandUserType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}